共享数据
---
**修改**共享数据会引发潜在问题

不变量(invariants)
修改共享数据，致使不变量遭到破坏
> 不变量的概念很模糊-_-，似乎是不能改变的量？？

#### 条件竞争
取决于一个以上线程的相对执行顺序
良性竞争：改变线程的执行顺序，结果可接受
恶性竞争：

条件竞争对时间敏感，难以通过调试模式复现


#### 避免恶性条件竞争
1. 对数据结构采取保护机制：确保**仅进行修改的线程**可看见不变量被破坏时的中间态
2. 对数据结构和不变量的设计进行修改，保证每个不变量处于稳定状态：无锁编程
3. 使用**事务**的方式去处理数据结构的更新
> 将所需的数据和读取存储在事务日志中，然后将之前的操作合为一步提交，若数据结构被其余线程修改，则提交无法进行
（软件事务内存）

最基本方式：C++提供的**互斥量**概念


互斥量保护共享数据
---
思想：将所有想访问共享数据结构的代码标记为互斥，则其余线程访问前需等待当前线程执行完毕。如此，同一时刻仅一个线程可访问共享数据

访问共享数据前，先使用互斥量锁住相关数据，访问结束后再解锁
互斥量自身存在缺陷：可能会造成死锁

std::mutex
---
不建议直接调用成员函数`lock()`上锁，因为不可忘记在函数出口处调用`unlock()`;
C++提供`std::lock_guard`，构造时上锁，析构时解锁，可确保已锁的互斥量必然能被正确地解锁

一般将锁和欲保护的变量置于同一类中封装
> 注意：当成员函数返回保护数据的指针or引用时，会破坏对其的保护。具有访问能力的指针或引用可访问修改被保护的数据（不受互斥锁限制）

==此外，保护数据作为运行时参数也可能导致mutex失效==

> 不能将保护数据的指针或引用传递至互斥锁的作用域之外


#### 接口可能存在竞争
例如两个线程对同一个stack进行访问操作
empty->top->pop

可能出现以下几种情况
`top1->top2->pop1->pop2`
`top1->pop1->top2->pop2`
显然两种情况下，top得到的结果截然不同

stack设计时将`pop`和`top`操作分开
避免一种情况：如果两操作合并一起时，pop出数据时发生了异常，既没有成功输出返回值，内部相应内存也被释放
此时，数据被丢失

解决：
- 传入一个引用？？
- **无异常抛出**的拷贝构造函数或移动构造函数
- 返回指向弹出值的指针，而不是直接返回值（指针可自由拷贝且不会产生异常）

锁的粒度太小可能会无法覆盖需保护的操作
而粒度过大也存在问题：
1. 性能下降：一个全局互斥锁保护全部共享数据，当共享数据过多时性能下降明显

死锁
---
每个线程都有一个互斥量，且均在等待对方释放互斥量
起因：多个互斥量锁定一个操作

避免死锁的方式：总以相同的顺序给两个互斥量上锁，如**必然**在互斥量B之前锁住A

`std::lock`可一次性锁住多个互斥量

#### 避免死锁的经验
1. 避免嵌套锁：当线程已获得一个锁时，不要再获取第二个（需获取多个锁时，使用std::lock) (串行地取得锁，可能在取得第一个锁后，第二个锁取不到)
2. 避免在有锁时调用用户代码：用户代码可能会获取锁
