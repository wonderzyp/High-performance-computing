入门
---

## TCP
### 服务端
1. 创建套接字
2. 初始化地址结构体`sockaddr_in`(IP地址可INADDR_ANY)
3. 调用`bind()`将结构体信息绑定至套接字
4. 监听`listen()`
5. 使用`accept()`返回新的`socket`，建立连接通信.

### 客户端
1. 创建套接字
2. 初始化地址结构体`sockaddr_in`
3. `connect()`请求连接指定的IP地址

### TCP的部分特性
#### 数据收发无边界
设想一种情况：客户端调用`read()`读取服务端传回的字符串，但是当字符串过长时，可能会分成多次传回，即客户端调用`read()`时字符串可能尚未完全传送完成
为解决此问题，可在应用层定义传输协议：
以**server_op**为例，定义传输数据首位数据记录总操作个数，在服务端通过`while((opnd_cnt*OPSZ+1)>recv_len)`保证数据全部接受完毕再进行计算

> 建立套接字通信时，必然需要双方的IP地址和端口：
服务端通过调用`bind`显式绑定`sockaddr_in`，`accept`获取连接的客户端信息；
客户端在`connect`时自动分配

## UDP
UDP不同于TCP，没有请求连接的过程，不用区分客户端和服务端
UDP收发数据存在边界，接受和发送的次数需一致


半关闭
---
当两台主机建立套接字连接以后，每个主机拥有单独的输入输出流。
`close()`函数意味着完全断开两个流，同时失去发送和接受数据的功能；
`shutdown()`可实现单方面关闭某一流的功能

仅关闭TCP输入、输出流中的一个，保持另一个的开放状态
如此，服务端在传输完毕后，依旧可以接受客户端的反馈等信息




多进程
---

#### 僵尸进程
僵尸进程：Linux下，子进程main函数return后不会消失，可通过以下几种方式销毁：
1. wait: 一直阻塞直到有子进程终止，wait将返回值保存至status内
2. waitpid：类似自旋锁，不会阻塞
3. 信号：SIGALRM, SIGINT, SIGHLD(子进程终止信号)

父进程可借助status获取子进程的返回值


