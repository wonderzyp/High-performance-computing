并发数据结构的设计、并发代码设计


并发数据结构设计
---
若一种数据结构可被多个线程访问，且值可能会发生变化，此时需对数据结构进行正确的设计
目的：多线程环境下可**正确的同步**
手段：
- 独立的互斥量
- 设计能够并发访问的数据结构

#### 数据结构并发设计的意义
并发数据结构允许多个线程并发地进行访问
多线程下无数据丢失和损毁、无条件竞争

#### 实例1：线程安全栈
`empty()`和`pop()`可能存在潜在的竞争，在pop上锁时，显式地查询栈是否为空，此处竞争非恶性

`pop()`对弹出值直接返回，可避免`std::stack`中top和pop成员函数之间的潜在竞争

##### 不安全因素
**1. empty失效**
`empty`与`pop`：设想一个场景，欲先调用empty判定栈非空后，调用pop释放栈顶元素
但在调用empty后，可能另一个线程调用了pop，使得当前线程的empty结果失去意义
可在pop内调用empty，因为调用pop时已经上锁，可保证empty结果的正确性。

`empty()`和`size()`均存在类似问题，在被调用并返回时是正确的，但其结果往往不可靠。
以下列代码块为例：
```cpp
stack<int> s;
if (! s.empty()){    // 1
  int const value = s.top();    // 2
  s.pop();    // 3
  do_something(value);
}
```
在操作1和2之间，可能有另一个线程执行了pop操作，如此top函数可能会作用于一个空栈，进而导致未定义行为。
如此，即使对特定变量进行保护，也无法阻止条件竞争的发生

此外，在操作2和3之间存在隐患
假设有两个线程a,b，均执行`top->pop`
我们希望`a.top->a.pop->b.top->b.pop`
但实际上可能`a.top->b.top->a.pop->b.pop`
虽然通过互斥量保证同一时刻仅一个线程可访问共享的成员变量，但成员函数之间依旧存在潜在的竞争

**问题2：pop丢失元素**
当拷贝一个`vector`时，标准库会从堆上分配较多内存完成拷贝。但如果资源有限，会抛出`std::bad_alloc`异常

pop弹出返回值时，只有当值被返回到调用函数时，栈才会被改变。如果拷贝数据时抛出异常，弹出的值会消失，且从栈上消失，如此这个值不见了

因此，`std::stack`将操作分为`top`和`pop`两部分，即使无法完成安全拷贝，栈中数据依旧存在。
显然，这种设计导致了条件竞争

**问题3：借口间竞争**
解决：传入引用


ps：
拷贝构造函数必须以引用方式传递参数，因为值传递会调用拷贝构造函数生成函数的实参，如无限循环调用下去，直到函数的栈溢出

拷贝构造函数：创建了一个新的对象实例
赋值运算符：将对象值赋予一个**已存在的实例**

拷贝构造函数的使用场景：
- 对象为函数的参数，且值传递
- 对象为函数的返回值，以值的形式返回
- 使用一个对象给另一个对象初始化

深拷贝和浅拷贝
主要针对类中的指针和动态分配的空间而言
对指针的简单值复制，不能分割开两个对象的关联，对一个对象的操作会影响另一个对象
深拷贝旨在消除这类影响
原则：
1. 值类型直接复制
2. 指针和动态分配的空间，在拷贝中应重新分配空间
3. 基类应调用合适的拷贝方法？？？？？？




异常源：
1. 对互斥量上锁可能抛出异常，但上锁是成员函数的第一个操作，极其罕见（问题出在系统资源上）
2. push可能抛出异常：内存不足或拷贝/移动数据值时
3. 



#### 实例2：线程安全队列



有以下两个考虑：
##### 访问是安全的（线程安全的）
- 数据结构中不变量被破坏时，不会有线程看见（类似临界区的感觉）
- 小心会引发条件竞争的接口
- 注意数据结构的行为是否会产生异常，进而影响“不变量”的稳定性
- 将死锁概率降至最低，避免嵌套锁的存在

##### 可真正的并发访问
- 锁范围中的操作，是否允许在锁外执行？
- 数据结构中不同区域是否可被不同的互斥量保护？
- 所有操作均需同级互斥量保护吗？

> 核心：最小化序列化访问，最大化真实并发



线程间划分工作
---
#### 并行化for_each
每个线程分配一定量的数据，并在各自的数据集上执行**相同**的操作

如果对一个很大的数据集进行排序，每层递归会产生一个新线程，最终生成大量线程而影响性能



考虑多性能性能的数据结构设计
---


有时类的拷贝无意义，如`std::mutex`
拷贝一个互斥量没有意义
`std::unique_lock<>`一个实例仅一个锁，仅转移实例的所有权有意义


锁粒度太小可能导致条件竞争
粒度太大可能影响性能

一个操作需两个及以上互斥量时，可能产生死锁

