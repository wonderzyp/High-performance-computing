对线程间进行同步：某个线程需等待另一个线程完成（或某些特定事件的发生）

**条件变量**、**期望**

选择1：不断询问，浪费资源
2：指定周期性歇息时间，但sleep时间的选择至关重要
3：C++标准库提供的工具--条件变量

条件变量
---
`std::condition_variable`成员函数：
- `wait()`传递一个锁和一个lambda表达式作为等待条件，条件满足时返回
若条件不满足，解锁互斥量，阻塞该线程
当被notify_one()通知时，线程从睡眠中苏醒并获取互斥锁，并检测条件
条件满足时从wait返回并继续持有锁，条件不满足则解锁并继续等待
- `notify_one()`通知所有等待的线程

> 似乎`notify_one()`是无差别通知，具体是否执行由线程自身判断

`std::lock_guard`不如`std::unique_lock`灵活，由于线程在等待期间需频繁地解锁上锁，故选择`std::unique_lock`
如果选择使用`std::lock_guard`，线程在休眠中依旧对互斥量上锁，此时前置线程无法正常处理任务，如此休眠线程的条件永远无法满足

`wait()`可传任意函数，需注意函数中不能有副作用（有点类似assert）
调用`wait`时，一个条件变量可能去检查给定条件**若干次**，若传入的函数有副作用，可能在唤醒前执行多次


等待线程仅等待一次，条件为`true`时，不会再等待条件变量


future-期望
---
future:提供访问异步操作结果的机制，通过async, packaged_task或promise创建
可查询、等待或从std::future中提取值，若依旧未提供值，可能会**阻塞**

async使用时不需要绑定线程
packaged_task和promise可绑定

#### `std::packaged_task`
将可调用对象进行包装

#### `std::promise`
提供存储值或异常的设施，每个promise与共享状态关联
promise可对共享状态做三件事：
- 使就绪
- 释放
- 抛弃




当一个线程需等待一个特定的一次性事件时
在等待任务期间，可先执行其余的一些任务，直到对应的任务触发

唯一期望
共享期望

`std::future`的实例仅与一个指定事件相关联

`std::launch::async`
`std::launch::deferred`：函数调用被延迟到`wait`或`get`函数调用时执行

std::packaged_task
---
用于包装任何可调用**callable**目标（函数、lambda表达式、bind表达式或其余函数对象），使得可异步调用，其返回值或所抛异常存储于std::future对象访问的共享状态中


`std::promises`：
上下文频繁切换（线程数量超出硬件的可接受并发数）
每个promise与共享状态关联，可对共享状态做三件事：
1. 使就绪：
2. 释放：放弃对共享状态的引用
3. 抛弃：



