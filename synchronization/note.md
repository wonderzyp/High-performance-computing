对线程间进行同步：某个线程需等待另一个线程完成（或某些特定事件的发生）

**条件变量**、**期望**

选择1：不断询问，浪费资源
2：指定周期性歇息时间，但sleep时间的选择至关重要
3：C++标准库提供的工具--条件变量

条件变量
---
`std::condition_variable`成员函数：
- `wait()`传递一个锁和一个lambda表达式作为等待条件，条件满足时返回
若条件不满足，解锁互斥量，阻塞该线程
当被notify_one()通知时，线程从睡眠中苏醒并获取互斥锁，并检测条件
条件满足时从wait返回并继续持有锁，条件不满足则解锁并继续等待
- `notify_one()`通知所有等待的线程

> 似乎`notify_one()`是无差别通知，具体是否执行由线程自身判断

`std::lock_guard`不如`std::unique_lock`灵活，由于线程在等待期间需频繁地解锁上锁，故选择`std::unique_lock`
如果选择使用`std::lock_guard`，线程在休眠中依旧对互斥量上锁，此时前置线程无法正常处理任务，如此休眠线程的条件永远无法满足

`wait()`可传任意函数，需注意函数中不能有副作用（有点类似assert）
调用`wait`时，一个条件变量可能去检查给定条件**若干次**，若传入的函数有副作用，可能在唤醒前执行多次


等待线程仅等待一次，条件为`true`时，不会再等待条件变量


future-期望
---
当一个线程需等待一个特定的一次性事件时
在等待任务期间，可先执行其余的一些任务，直到对应的任务触发

唯一期望
共享期望

`std::future`的实例仅与一个指定事件相关联

`std::async`：启动异步任务，会返回一个`std::future`对象，该对象持有最终计算出的结果，需要值时调用`get`成员函数

``







